
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Wheelchair Basketball Project</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="index.css">
    <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
</head>

<body>
    <!-- Add later navbar-fixed-ontop -->
<nav class="navbar transparent navbar-inverse" >
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="collapse navbar-collapse" id="myNavbar">
                                <ul class="nav navbar-nav navbar-left">
                    <a><font color="black"> Team 31 - Wheelchair Basketball Project</font></a>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li class="underlined active"><a href="index.html" class="fix-underline-a"><font color="black">HOME</font></a></li>
                    <li class="underlined"><a href="requirements.html"><font color="black">REQUIREMENTS</font></a></li>
                    <li class="underlined"><a href="research.html"><font color="black">RESEARCH</font></a></li>
                    <li class="underlined"><a href="hci.html"><font color="black">HCI</font></a></li>
                    <li class="underlined"><a href="design.html"><font color="black">DESIGN</font></a></li>
                    <li class="underlined"><a href="testing.html"><font color="black">TESTING</font></a></li>
                    <li class="underlined"><a href="evaluation.html"><font color="black">EVALUATION</font></a></li>
                    <li class="underlined"><a href="management.html"><font color="black">MANAGEMENT</font></a></li>
                </ul>
            </div>
        </div>
    </nav>

 <div class="container">
    <div class="row">
        <div id="my=nav" class ="span3">
            <ul class="nav nav-list affix">
                <li><a href="#section1">Test Strategies</a></li>
                <li><a href="#section2">Unit Testing</a></li>
                <li><a href="#section3">User Acceptance Testing</a></li>
                <li><a href="#section4">UI Testing</a></li>

            </ul>
        </div>
        <div class="span9 my-content">
            <section id="section1"> 
                    <div class="container text-center">
                        <h2><strong> Test Strategies</strong></h2>
                    </div>

                    <div class="container text-center">
                        <h3><strong>Functional Testing</strong></h3>
                        <p> Functional testing is a type of black box testing that is concerned with checking the functionalities of the code. This means it doesn't look at the internal code structure and is instead based entirely on the software requirements and specifications. To implement functional testing, the following steps should be taken:</p>
                        <p>1. Identify test input data</br>
                        2. Compute expected outcomes</br>
                        3. Execute test cases </br>
                        4. Comparison of actual and computed expected result</p>
                    </div>


                    <div class="container">
                        In order to carry out functional testing, we needed to check our functional requirements so we knew what to test. Looking at our MoSCow Requirements, we can test the following functionalities with functional testing:</div>
                        <div class="container">
                        <p>1. Must display game data</br>
                        2. Should display the user's weight to allow them to track it</br>
                        3. Should calculate average speed</br>
                        4. Should calculate average calories burnt, distance travelled, speed, active minutes across game</br>
                        5. Should show the average statistics between set time frames</br>
                        6. Could display the analysis using graphs, charts and other data visualisations</p>

                        <p> For the features that require data to be <b>displayed</b> (i.e. 1, 2, and 6), the we will use the following implementation of the standard functional testing steps:</p>

                        

                        
                    </div>

                    <table class="table table-striped">
                      <thead>
                        <tr>
                          <th></th>
                          <th>Step</th>
                          <th>Implementation</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <th scope="row"></th>
                            <td><b>Identify test input data</b></td>
                                              <td>In our case this will be the mock json file with data in a similar format to the data retrieved from the fitbit API. This represents the incoming data from the sensor worn by the user.
                                </td>
                        </tr>
                        <tr>
                              <th scope="row"></th>
                              <td><b>Computer expected outcomes</b></td>

                              <td>The expected outcome doesn't need to be 'computed' as such. Instead, the expected outcome is to observe that the data has in fact been displayed on the application. </td>
                        </tr>
                        <tr>
                              <th scope="row"></th>
                              <td><b>Execute test cases</b></td>

                              <td>Execution will involve running the application after inputting data. </td>
                        </tr>
                            <tr>
                              <th scope="row"></th>
                              <td><b>Comparison of actual and computed expected result</b></td>
                              <td>The comparison will involve checking the expected data is displayed. To solidify this result further testing is required, such as user testing, to ensure the data is in the correct format so that we can deduce that it has been correctly displayed.</td>
                        </tr>
                      </tbody>
                    </table>

                    <p> For the features that require data to be <b>calculated</b> (i.e. 3, 4, and 5), the we will use the following implementation of the standard functional testing steps:</p>

                <table class="table table-striped">
                      <thead>
                        <tr>
                          <th></th>
                          <th>Step</th>
                          <th>Implementation</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <th scope="row"></th>
                            <td><b>Identify test input data</b></td>
                                              <td>As the json file generator we created only generates random values, we will use sample data for the calculation tests, so that we can choose the values ourselves. We will create sample arrays in the same form as those that can be derived from the json files. 
                                </td>
                        </tr>
                        <tr>
                              <th scope="row"></th>
                              <td><b>Computer expected outcomes</b></td>

                              <td>We will use simple values for our sample data and manually calculate the averages. </td>
                        </tr>
                        <tr>
                              <th scope="row"></th>
                              <td><b>Execute test cases</b></td>

                              <td>Again, execution will involve running the application after inputting data. </td>
                        </tr>
                            <tr>
                              <th scope="row"></th>
                              <td><b>Comparison of actual and computed expected result</b></td>
                              <td>The comparison will involve checking the expected data that we manually calculated is displayed.</td>
                        </tr>
                      </tbody>
                    </table>


                    <div class="container text-center">
                        <h3><strong>System Testing</strong></h3>
                        <p> System testing aims to figure out whether whether the whole system fulfills the requirments given to it. System testing differs from functional testing in that it takes into consideration the application as a whole, as opposed to checking a given part of the whole system. Like functional testing, system testing is a method of black box testing, and does not look at the internal code of the application.</p>
                        <p> Because of this, we followed the same steps for our system testing strategy as we did for the functional testing. However the implementation will look at broader elements. </p>
                        <table class="table table-striped">
                              <thead>
                                <tr>
                                  <th></th>
                                  <th>Step</th>
                                  <th>Implementation</th>
                                </tr>
                              </thead>
                              <tbody>
                                <tr>
                                  <th scope="row"></th>
                                    <td><b>Identify test input data</b></td>
                                                      <td>The input 'data' for the whole system is both the data from the mock json files we have generated and also the user input of the user interface, such as pressing buttons and entering information into fields.
                                        </td>
                                </tr>
                                <tr>
                                      <th scope="row"></th>
                                      <td><b>Computer expected outcomes</b></td>

                                      <td>The outcome we expect from our system is a mobile application that both displays raw data from the sensors and also calculates averages and displays the resulting statistics. Additionally, the application should be navigable and allow each user to create and log into a unique account.</td>
                                </tr>
                                <tr>
                                      <th scope="row"></th>
                                      <td><b>Execute test cases</b></td>

                                      <td>To test the system, we will act as an end user and attempt to create an account, log in and navigate through the app. In terms of the back end functionality, we will create a mock json file using our generator to replicate the collection of data from a fitbit sensor.</td>
                                </tr>
                                    <tr>
                                      <th scope="row"></th>
                                      <td><b>Comparison of actual and computed expected result</b></td>
                                      <td>Throughout the execution of the tests, we will ensure the navigation is functional and ensure the data and averages are displayed on the application.</td>
                                </tr>
                              </tbody>
                            </table>
                        </div>
                        <div class="container">

                        <p> Both functional and system testing have a similar, user-focused approach to testing and therefore both have the following advantages and disadvantages:</p>
                    </div>
                    <div class="container text-center">
                            <div class="col-sm-6">
                                <img src="img/success.png">
                                <li>The tester is not required to have any programming knowledge.</li>
                                <li>Tests focus on the user end so can identify issues the designer may not have taken into consideration.</li>
                                <li>Simulates actual system usage.</li>
                                <li>Ensures requirements are properly satisfied.</li>

                            </div>

                            <div class="col-sm-6">
                                <img src="img/error.png">
                                <li>Doesn't take internal elements into consideration, such as time taken for specific functions to execute.</li>
                                <li>If elements tested have already been taken into consideration during internal testing, the tests will be redundant.</li>
                                <li>It may be difficult to identify the reason for a functionality not to be working as the tests do not look at the code itself.</li>
                            </div>
                    </div>
                    <div class="container text-center">
                        <h3><strong>Stress Testing</strong></h3>
                        <p> Stress testing is a method that puts an application under extreme conditions as a way of testing the behaviour of the application beyond normal circumstances. In this way, stress testing allows the developer to detect the robustness of the application and to understand the upper limits of the capacity within the system. This will in turn improve error handling by considering 'worst-case' scenarios. </p></div>

                    <div class="container text-center">
                        <b>1. Mission Critical Application</b> 

                        <p>Stress testing is necessary for a number of reasons, most significantly for applications which possess potential risks of high severity. For this reason, stress testing is relevant for our application as it provides health-related data for, in some cases, medically vulnerable people and therefore the failure of the application could have disastrous consequences. Applications with this characteristic are said to be 'mission critical'. </p>

                        <p>Our strategy of stress testing to prevent risks will be to use extreme numbers of json files as sample data. To implement this, we have developed our json file generator so that it can produce hundreds of files. Performing functional testing on this number of json files will ensure the consistency of accuracy of the application. </p>
                    </div>

                    <div class="container text-center">
                        <b>2. Varying Available Computational Resources</b>
                        <p>Stress testing is also necessary because the end user of our application may have fewer computational resources i.e. an older, less powerful phone that the one we have used to develop the appliciation. Hwoever, we need to make sure the application is compatible on all potential user's phones. For this reason it is imperative that we check our application is functional on such a device. </p>

                        <p>The strategy for this is simply to run the application on a much older device. Thankfully, android studio offers the option to select the device used for the emulator, so this test will be straight forward.</p>
                    </div>
                    <div class="container text-center">

                        <p>In general, certain issues with our application may not be visible in the short amount of time we have been working on it. Stress testing for a relatviely short amount of time is a method of simulating normal operation for a longer period of time, in an attempt to detect previously hidden bugs. There are a number of advantages and disadvantages associated with stress testing:</p> 
                    </div>

                    <div class="container text-center">
                            <div class="col-sm-6">
                                <img src="img/success.png">
                                <li>Can be done with limited time.</li>
                                <li>Results in robust application.</li>
                            </div>

                            <div class="col-sm-6">
                                <img src="img/error.png">
                                <li>Doesn't take all values into consideration, only extreme values.</li>
                                <li>Doesn't test actual functionality.</li>
                                <li>Doesn't represent how the application will actually be used.</li>
                            </div>
                    </div>
                    <div class="container text-center">
                        <h3><strong>Performance Testing</strong></h3>
                        <p>Performance testing is a method that strives to build performance standards into the implementation, design and architecture of the system. It serves the purpose of demonstrating that the system meets performance criteria and can be used to identify parts of the system that cause the system to perform badly. There are a number of different types of performance testing we have devised strategies for: </p>
                        <table class="table table-striped">
                              <thead>
                                <tr>
                                  <th></th>
                                  <th>Type of Testing</th>
                                  <th>Implementation</th>
                                </tr>
                              </thead>
                              <tbody>
                                <tr>
                                  <th scope="row"></th>
                                    <td><b>Load Testing- to understand the behaviour of the system under a specific load</b></td>
                                                      <td>The 'load' we will specify will be the number of json files we test with. This can be used to represent the number of expected uses, i.e. number of expected sets of incoming data. 
                                        </td>
                                </tr>
                                <tr>
                                      <th scope="row"></th>
                                      <td><b>Isolation Testing- to confirm the fault domain of a problem</b></td>

                                      <td>Whan an issue or error occurs, we will repeat and narrow test execution in order to isolate functionalities and determine where the problem is.</td>
                                </tr>
                                <tr>
                                      <th scope="row"></th>
                                      <td><b>Stress Testing- to determine upper limits of capacity of system</b></td>

                                      <td>As previously mentioned.</td>
                                </tr>
                              </tbody>
                            </table>
                    </div>
            </section>

    <section id="section2">
                    <div class="container text-center">
                        <h2><strong> Unit Testing</strong></h2>
                    </div>


                    <div class="container text-center">
                        
                        <p>As part of the unit testing for our Android application, we are developing local unit tests that can run on the JVM. These tests run much faster than the time required to deploy and run tests on an Android device, and ensure stability of each section within the whole application.</p>

                        <p>For our unit tests, we have created a sample json file, as this is the form in which data will come from the fitbit API. The first task is to retrieve data from the json file and convert it to a string. From there, our unit tests take the string and interprets it as an array. This allows us to retrieve individual objects from the file. </p>
                </div>
                <div class="container text-center">

                <p>The first two tests check that the data is in the correct form; it checks that all times are strings and all heart rates are integers. The next test ensures each element refers to the correct data. More specifically, we are checking that each time is mapped to the correct heart rate. 
                 </p>
                    </div>
            </section>  
            <section id="section3"> 
                    <div class="container">
                        <h2><strong> Acceptance Testing</strong></h2>
                    </div>


                    <div class="container text-center">
                        
                        <p>As our application is to be used by a client with potentially no technical expertise, it is essential that we undergo usability testing. In this way, we can spot and fix problems before the application is finished. As part of our usability testing process, we considered the following five elements: </p>
                    </div>

                    <div class="container text-center">
                        <h3><strong>1. Learnability</strong></h3>
                    </div>


                    <div class="container text-center">     
                        <p>Learnability refers to how easy it is for users to accomplish basic tasks the first time they encounter the design. As part of our test for learnbility, we asked our client to use the application with no prior instruction as to how it works. Our application only has few buttons and each button is labeled. For this reason the app needs no further instruction set and there for is very learnable. </p>
                    </div>
 
                    <div class="container text-center">
                        <h3><strong>2. Efficiency</strong></h3>
                    </div>

                    <div class="container text-center">     
                        <p>Our next point to take into consideration for usability testing is the efficiency of the application.Following review, we noticed that this is something that could be improved about our application. To navigate through the application, the user has to click on a number of consecutive buttons, and there is no easy go-to menu. For this reason it can take a long time for the user to find the information they want.  </p>
                    </div>

                    <div class="container">
                        <h3><strong>3. Memorability</strong></h3>
                    </div>

                    <div class="container text-center">     
                        <p>Memorability refers to how easy it is for the user to use the application after perhaps not using it for some time. However, our application is so simplistic that this links to learnability; the app is very easy to use without need of further instruction and therefore a user should not forget, or will not need to remember, how to use the application.   </p>
                    </div>

                 <div class="container">
                        <h3><strong>4. Errors</strong></h3>
                    </div>

                    <div class="container text-center">     
                        <p>We could consider an error from the user an incorrect button pressed, as the application is for the display of data rather than modification from the user, Although this is not troublesome in terms of severity affecting the functionality of the app, it may be frustrating for the user to navigate back to where they were in the application, as this was already identified as an issue regarding efficiency. </p>
                    </div>

                 <div class="container">
                        <h3><strong>5. Satisfaction</strong></h3>
                    </div>

                    <div class="container text-center">     
                        <p>Satisfaction refers to how much the user likes using the program. For those who value simplicity, the application is enjoyable to navigate and use. However, the application could be made more aesthetically pleasing with more colours, images and interactive features. </p>
                    </div>


            </section>    

            <section id="section4"> 
                    <div class="container">
                        <h2><strong> UI Testing</strong></h2>
                    </div> 
                    <div class="container text-center">
                        <p>One approach we initially considered to test our user interface was to manually perform a set of user operations on our application and verify that is is behaving correctly. However, this can be time-consuming, tedious and error-prone. Instead, we decided to write automated UI tests to perform the operations, allowing us to run our tests quickly and reliably in a repeatable manner. </p>
                        <p>To perform the automated tests on our application in Android Studio, we used the testing framework Espresso.</p>
                    </div>
            </section>  
</div>
</div>
</div>




    <footer class="footer-distributed">


        <div class="footer-left">
            <p>
                
                COMP214P Systems Engineering - Team 31
            </p>
        </div>

    </footer>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</body>

</html>
